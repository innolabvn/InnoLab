{"critical":[{"cwe_ids":["502"],"id":"python_lang_avoid_pickle","title":"Usage of unsafe Pickle libraries","description":"## Description\n\nUsing pickle, _pickle and cPickle can make your application vulnerable to unsafe code execution. This is because the deserialization logic of these libraries allows for arbitrary code execution. It is best practices to avoid these libraries and to use a safer serialization formats like JSON.\n\n## Remediations\n\n- **Do not** use pickle or its derivatives for deserialization wherever possible. These libraries are open to security vulnerabilities.\n- **Do** use recommended safer formats like JSON, Protocol Buffers (protobuf) and MessagePack.\n  ```python\n    import msgpack #MessagePack\n\n    data = {'key': 'value'}\n    packed_data = msgpack.packb(data)\n  ```\n\n## References\n\n- [OWASP Deserialization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_avoid_pickle","line_number":14,"full_filename":"/scan/vulnerable_app.py","filename":"vulnerable_app.py","source":{"start":14,"end":14,"column":{"start":12,"end":30}},"sink":{"start":14,"end":14,"column":{"start":12,"end":30},"content":""},"parent_line_number":14,"fingerprint":"8da8af7c085e4cb2482aedfd54c619c5_0","old_fingerprint":"e48171269e83942040432d85161dc041_0","code_extract":"    return pickle.loads(data)"},{"cwe_ids":["95"],"id":"python_lang_eval_using_user_input","title":"Unsanitized user input in 'eval' type function","description":"## Description\n\nExecuting code with 'eval' or similar functions using unsanitized user input is risky and can lead to code injection vulnerabilities. This happens when external input is used directly in functions that execute code, allowing attackers to run malicious code within your application.\n\n## Remediations\n\n- **Do not** use `eval` or similar code execution functions with unsanitized user input. This can create a significant security risk by allowing code injection.\n- **Do not** use `ast.literal_eval()` with unsanitized user input. While `literal_eval` is often considered to be less risky than `eval` because it evaluates strings as Python data structures only (integers, strings, dictionaries,etc), an attacker could exploit this function with deeply nested structures that could cause excessive memory allocation or stack consumption.\n- **Do** use dynamic hardcoded values instead of direct user input to mitigate the risk of code injection. This approach allows for controlled execution of code without exposing your application to injected malicious code. For example, use a dictionary to store functions, and call these based on user input.\n  ```python\n  def total_with_vat(a, b):\n    total = a + b\n    return total + total * 0.15\n\n  def total_without_vat(a, b):\n    return a + b\n\n  get_total = {\n    \"incl_vat\": total_with_vat,\n    \"excl_vat\": total_without_vat\n  }\n\n  if form.cleaned_data[\"include_vat\"]:\n    total_func = get_total[\"incl_vat\"]\n    total = total_func(a, b)\n\n  # ...\n  ```\n\n## References\n\n- [OWASP Code injection explained](https://owasp.org/www-community/attacks/Code_Injection)","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_eval_using_user_input","line_number":40,"full_filename":"/scan/vulnerable_app.py","filename":"vulnerable_app.py","source":{"start":40,"end":40,"column":{"start":12,"end":27}},"sink":{"start":40,"end":40,"column":{"start":12,"end":27},"content":""},"parent_line_number":40,"fingerprint":"a7c4dc4905b0e68695716fd3302fc75d_0","old_fingerprint":"1c53c41eb6303a0d8d0d397e812dcba6_0","code_extract":"    return eval(user_code)"},{"cwe_ids":["78"],"id":"python_lang_os_command_injection","title":"Unsanitized user input in OS command","description":"## Description\n\nDirectly incorporating external or user-defined input into an OS command exposes the system to possible command injection attacks. This vulnerability allows attackers to execute unauthorized commands on the operating system, potentially leading to a compromise of system integrity.\n\n## Remediations\n\n- **Do not** use OS commands that include dynamic input directly. Instead, explore safer alternatives such as libraries or built-in functions that achieve the same goal without executing system commands. \n- **Do** use hardcoded values for any input that is incorporated into OS commands. This approach minimizes the risk by ensuring only predefined inputs are used, thus preventing attackers from injecting malicious commands. Use safe lists or dictionaries if you need to be dynamic. \n\n## References\n\n- [OWASP command injection explained](https://owasp.org/www-community/attacks/Command_Injection)","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_os_command_injection","line_number":27,"full_filename":"/scan/vulnerable_app.py","filename":"vulnerable_app.py","source":{"start":27,"end":27,"column":{"start":12,"end":44}},"sink":{"start":27,"end":27,"column":{"start":12,"end":44},"content":""},"parent_line_number":27,"fingerprint":"2f34e0c6e7e2b7614b1ff7bc7ad2c2a3_0","old_fingerprint":"5ea3611aa72b28978083ee5b572b6255_0","code_extract":"    return subprocess.call(cmd, shell=True)"},{"cwe_ids":["89"],"id":"python_lang_sql_injection","title":"Unsanitized external input in SQL query","description":"## Description\n\nUsing unsanitized data, such as user input or request data, or externally influenced data passed to a function, in SQL query exposes your application to SQL injection attacks. This vulnerability arises when externally controlled data is directly included in SQL statements without proper sanitation, allowing attackers to manipulate queries and access or modify data.\n\n## Remediations\n\n- **Do not** include raw external input in SQL queries. This practice can lead to SQL injection vulnerabilities.\n  ```python\n  sorting_order = request.GET[\"untrusted\"]\n  query = f\"SELECT id, name FROM products ORDER BY name LIMIT 20 {sorting_order};\"; # unsafe\n  ```\n- **Do** validate all external input to ensure it meets the expected format before including it in SQL queries.\n  ```python\n  sorting_order = \"DESC\" if request.GET[\"sortingOrder\"] == \"DESC\" else \"ASC\"\n  ```\n- **Do** use parameters for database queries to separate SQL logic from external input, significantly reducing the risk of SQL injection.\n  ```python\n  cursor.execute(\"SELECT * FROM products WHERE id LIKE ?\", [f\"%{product_id}%\"])\n  ```\n- **Do** escape all external input using appropriate database-specific escaping functions before including it in SQL queries.\n  ```python\n  from mysql.connector.conversion import MySQLConverter\n\n  converter = MySQLConverter(connection)\n  ok = converter.escape(request.GET[\"value\"])\n  ```\n\n## References\n\n- [OWASP SQL injection explained](https://owasp.org/www-community/attacks/SQL_Injection)\n- [OWASP SQL injection prevention cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_sql_injection","line_number":21,"full_filename":"/scan/vulnerable_app.py","filename":"vulnerable_app.py","source":{"start":21,"end":21,"column":{"start":5,"end":26}},"sink":{"start":21,"end":21,"column":{"start":5,"end":26},"content":""},"parent_line_number":21,"fingerprint":"08b4dd74e723ed7391eb22e42d6329e5_0","old_fingerprint":"f4c3a7d3b3070718f48a6a5c327c177e_0","code_extract":"    cursor.execute(query)"}],"high":[{"cwe_ids":["22"],"id":"python_lang_path_traversal","title":"Unsanitized dynamic input in file path","description":"## Description\n\nUsing unsanitized dynamic input to determine file paths can allow attackers to gain access to files and folders outside of the intended scope. This vulnerability occurs when input provided by users is directly used to access the filesystem without proper validation or sanitization.\n\n## Remediations\n\n- **Do not** directly use external input to construct file paths. This can lead to unauthorized file access.\n- **Do** use a safelist to define accessible paths or directories. Only allow user input to influence file paths within these predefined, safe boundaries.\n- **Do** use absolute path checks to confirm that the constructed path is within the expected directory\n    ```python\n    BASE_DIRECTORY = '/path/to/safe/directory'\n    my_path = os.path.abspath(os.path.join(BASE_DIRECTORY, dynamic_input))\n\n    if my_path.startswith(BASE_DIRECTORY):\n      open(my_path)\n   ```\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\n","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_path_traversal","line_number":35,"full_filename":"/scan/vulnerable_app.py","filename":"vulnerable_app.py","source":{"start":35,"end":35,"column":{"start":10,"end":43}},"sink":{"start":35,"end":35,"column":{"start":10,"end":43},"content":""},"parent_line_number":35,"fingerprint":"acfe614e32c7bf6a03146eef7ca4dd89_0","old_fingerprint":"a2e06a9a10331ab50ec644abf509a32a_0","code_extract":"    with open(f\"/var/www/{filename}\", 'r') as f:"}],"medium":[{"cwe_ids":["328"],"id":"python_lang_weak_hash_md5","title":"Usage of weak hashing library (MDx)","description":"## Description\n\nUsing a weak hashing library, such as MD5, increases the risk of data breaches. MD5 itself is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use MD5 for hashing. This algorithm is considered weak and vulnerable to attacks.\n  ```python\n  hashlib.md5('password').digest() # unsafe\n  ```\n- **Do** opt for stronger hashing algorithms like SHA-256 to enhance security.\n  ```python\n  hashlib.sha256('password').digest()\n  ```","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_weak_hash_md5","line_number":31,"full_filename":"/scan/vulnerable_app.py","filename":"vulnerable_app.py","source":{"start":31,"end":31,"column":{"start":12,"end":42}},"sink":{"start":31,"end":31,"column":{"start":12,"end":42},"content":""},"parent_line_number":31,"fingerprint":"54063400fd9ca7772ab846057c2875cb_0","old_fingerprint":"3e24d36a41f15e15a25b40b442af9d8d_0","code_extract":"    return hashlib.md5(password.encode()).hexdigest()"}]}

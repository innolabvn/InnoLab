{"critical":[{"cwe_ids":["502"],"id":"python_lang_avoid_pickle","title":"Usage of unsafe Pickle libraries","description":"## Description\n\nUsing pickle, _pickle and cPickle can make your application vulnerable to unsafe code execution. This is because the deserialization logic of these libraries allows for arbitrary code execution. It is best practices to avoid these libraries and to use a safer serialization formats like JSON.\n\n## Remediations\n\n- **Do not** use pickle or its derivatives for deserialization wherever possible. These libraries are open to security vulnerabilities.\n- **Do** use recommended safer formats like JSON, Protocol Buffers (protobuf) and MessagePack.\n  ```python\n    import msgpack #MessagePack\n\n    data = {'key': 'value'}\n    packed_data = msgpack.packb(data)\n  ```\n\n## References\n\n- [OWASP Deserialization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_avoid_pickle","line_number":126,"full_filename":"/scan/app.py","filename":"app.py","source":{"start":126,"end":126,"column":{"start":15,"end":33}},"sink":{"start":126,"end":126,"column":{"start":15,"end":33},"content":""},"parent_line_number":126,"fingerprint":"97c590b3c24fe6d7133f6e4d3358ab50_0","old_fingerprint":"8bb356c83b0e034773397d92146c07da_0","code_extract":"        obj = pickle.loads(blob)"},{"cwe_ids":["319"],"id":"python_lang_insecure_http","title":"Usage of insecure HTTP connection","description":"## Description\n\nYour application is at risk when it connects to APIs using insecure HTTP connections. This vulnerability occurs because HTTP lacks encryption, making data susceptible to interception and alteration. Always verify that your application exclusively uses HTTPS connections for enhanced security.\n\n## Remediations\n\n- **Do not** initiate connections using unsecured HTTP. This exposes your data to potential interception and manipulation.\n  ```python\n  urllib.request.urlopen(\"http://insecure-api.com\") # unsafe\n  ```\n- **Do** ensure all connections are made through HTTPS to encrypt data and protect against eavesdropping and tampering.\n  ```python\n  urllib.request.urlopen(\"https://secure-api.com\")\n  ```\n\n## References\n\n- [OWASP insecure transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_insecure_http","line_number":187,"full_filename":"/scan/app.py","filename":"app.py","source":{"start":187,"end":187,"column":{"start":9,"end":76}},"sink":{"start":187,"end":187,"column":{"start":9,"end":76},"content":""},"parent_line_number":187,"fingerprint":"2e018b6e4219d525e9e9f6283d2d8403_0","old_fingerprint":"39f7fc32933af44259c08b10f484d9a9_0","code_extract":"        requests.post(\"http://example.com/collect\", json={\"pwd\": password})"},{"cwe_ids":["347"],"id":"python_lang_jwt_verification_bypass","title":"Missing signature verification of JWT","description":"## Description\n\nFailing to verify the signature of JSON Web Tokens (JWTs) compromises the security of an application. Signature verification is crucial for confirming the authenticity and integrity of JWTs. Without this verification, your application is open to token forgery and replay attacks, where attackers can manipulate or reuse tokens to gain unauthorized access.\n\n## Remediations\n\n- **Do not** disable verification of the token's signature, because this leaves a significant security gap.\n  ```python\n  jwt.decode(token, options={\"verify_signature\": False}) # unsafe\n  ```","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_jwt_verification_bypass","line_number":139,"full_filename":"/scan/app.py","filename":"app.py","source":{"start":139,"end":139,"column":{"start":19,"end":94}},"sink":{"start":139,"end":139,"column":{"start":19,"end":94},"content":""},"parent_line_number":139,"fingerprint":"e53489cd0e178da1ee96baee89aee95e_0","old_fingerprint":"c396a9cd15fe8d0c482b8f691b0adad4_0","code_extract":"        payload = jwt.decode(token, options={\"verify_signature\": False, \"verify_aud\": False})"}],"high":[{"cwe_ids":["295"],"id":"python_lang_ssl_verification","title":"Missing SSL certificate verification","description":"## Description\n\nMissing or optional SSL certificate verification can compromise the security of sensitive data. This vulnerability arises when an application fails to check for valid SSL certificates during data transmission, potentially allowing attackers to intercept or manipulate data and leading to Man-in-the-Middle attacks. To protect against these kinds of attacks and to maintain secure communication, SSL certificates should always be properly validated in production environments.\n\n## Remediations\n\n- **Do not** disable SSL certificate verification in your HTTP client. Disabling it removes a critical layer of security and makes your application vulnerable to Man-in-the-Middle attacks.\n```python\nurllib3.HTTPSConnectionPool(..., cert_reqs=\"CERT_NONE\", ...) # unsafe\n# or\nrequests.get(..., verify=False, ...) # unsafe\n```\n- **Do** ensure SSL certificate verification is enabled when configuring connections, as well as hostname checking. For example, use `ssl.CERT_REQUIRED` to ensure SSL certificates are verified. \n  ```python\n  urllib3.HTTPSConnectionPool(\"my-host.com\", cert_reqs=ssl.CERT_REQUIRED, assert_hostname=True ...)\n  ```\n- **Do not** create custom SSL contexts that disable certificate verification\n```python\nctx = urllib3.create_urllib3_context(cert_reqs=ssl.CERT_NONE) # unsafe\n```\n\n## References\n- [Python 3 ssl module security considerations](https://docs.python.org/3/library/ssl.html#ssl-security)","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_ssl_verification","line_number":90,"full_filename":"/scan/app.py","filename":"app.py","source":{"start":90,"end":90,"column":{"start":9,"end":51}},"sink":{"start":90,"end":90,"column":{"start":9,"end":51},"content":""},"parent_line_number":90,"fingerprint":"973982c3a3525d3706e7bd03aabb5970_0","old_fingerprint":"8ef32c0a91af661f8a47682b98c53ea6_0","code_extract":"    r = requests.get(url, verify=False, timeout=2)"}],"medium":[{"cwe_ids":["328"],"id":"python_lang_weak_hash_md5","title":"Usage of weak hashing library (MDx)","description":"## Description\n\nUsing a weak hashing library, such as MD5, increases the risk of data breaches. MD5 itself is vulnerable to collision attacks, where two different inputs can produce the same hash value, compromising data integrity and security.\n\n## Remediations\n\n- **Do not** use MD5 for hashing. This algorithm is considered weak and vulnerable to attacks.\n  ```python\n  hashlib.md5('password').digest() # unsafe\n  ```\n- **Do** opt for stronger hashing algorithms like SHA-256 to enhance security.\n  ```python\n  hashlib.sha256('password').digest()\n  ```","documentation_url":"https://docs.bearer.com/reference/rules/python_lang_weak_hash_md5","line_number":48,"full_filename":"/scan/app.py","filename":"app.py","source":{"start":48,"end":48,"column":{"start":16,"end":46}},"sink":{"start":48,"end":48,"column":{"start":16,"end":46},"content":""},"parent_line_number":48,"fingerprint":"65c9c2496677f21552e48b34c59791e4_0","old_fingerprint":"2c3679d5006289335d1d5bf3dbb64216_0","code_extract":"    pwd_hash = hashlib.md5(password.encode()).hexdigest()"}]}

2025-08-21 14:36:11,954 - INFO - TEMPLATE_USAGE: {"file_path": "source_bug\\code.py", "template_type": "fix", "custom_prompt": null, "prompt_length": 9282, "prompt_preview": "### Role\nYou are a Senior Software Engineer. Act to fix real production bugs with minimal, precise changes.\n\n### Inputs (Context)\n- Source code: \n```\n\"\"\"\nbuggy_app.py - Intentionally buggy Python sour..."}
2025-08-21 14:37:02,508 - INFO - AI_RESPONSE: {"file_path": "source_bug\\code.py", "raw_response_length": 28289, "cleaned_response_length": 7108, "response_preview": "\"\"\"\nbuggy_app.py - Intentionally buggy Python source for testing RAG + static analyzers.\nContains 20+ distinct issues (bugs, code smells, vulnerabilities, bad practices).\nEach issue is annotated with ...", "full_cleaned_response": "\"\"\"\nbuggy_app.py - Intentionally buggy Python source for testing RAG + static analyzers.\nContains 20+ distinct issues (bugs, code smells, vulnerabilities, bad practices).\nEach issue is annotated with a BUG-ID tag for easier tracking.\n\"\"\"\n\nimport os\nimport json\nimport random\nimport sqlite3\nimport threading\nfrom datetime import datetime\n\n# BUG-001: Hardcoded credentials (security smell)\nDB_USER = \"admin\"\nDB_PASS = \"123456\"  # weak password\n\n# BUG-002: Mutable default argument\ndef append_item(item, bucket=None):\n    bucket = bucket or []\n    bucket.append(item)\n    return bucket\n\n# BUG-003: Swallowing broad exception; BUG-004: Unused variable; BUG-005: Shadowing built-in 'list'\ndef load_config(path: str) -> dict:\n    list = []  # shadowing built-in\n    try:\n        with open(path) as f: # fixing BUG-006, resource leak by using with statement\n            return json.loads(f.read())\n    except (FileNotFoundError, json.JSONDecodeError):  # catch specific exceptions. Fixing BUG-003\n        err = \"ignored\"\n        return {}  # silently ignore errors\n\n# BUG-007: Inefficient string concatenation in loop; BUG-008: Off-by-one\ndef join_numbers(n: int) -> str:\n    s = [str(i) for i in range(n)]  # should be range(n)\n    s = \",\".join(s)\n    return s.rstrip(\",\")\n\n# BUG-009: Using eval on untrusted input (security)\ndef compute(expr: str) -> int:\n    return eval(expr)  # nosec\n\n# BUG-010: SQL injection via string formatting; BUG-011: Unparameterized query\ndef get_user_row(db_path: str, username: str):\n    conn = sqlite3.connect(db_path)\n    cur = conn.cursor()\n    #q = f\"SELECT * FROM users WHERE name = '{username}'\"  # injection\n    q = \"SELECT * FROM users WHERE name = ?\" # fixing BUG-010 and BUG-011. Using parameterized query to prevent SQL injection\n    cur.execute(q, (username,))\n    row = cur.fetchone()\n    conn.close()\n    return row\n\n# BUG-012: Insecure randomness for security token\ndef insecure_token() -> str:\n    return str(random.randint(0, 999999))\n\n# BUG-013: Race condition writing temp file; BUG-014: Not using with-statement\ndef write_temp(data: str, tmp_path: str):\n    if not os.path.exists(tmp_path):\n        with open(tmp_path, \"w\") as f: # no lock, not using context manager. Fixing BUG-013 & BUG-014 using with statement\n            f.write(data)\n    else:\n        with open(tmp_path, \"a\") as f:\n            f.write(data)\n\n# BUG-015: Duplicate code / DRY violation\ndef sum_list(a):\n    total = 0\n    for x in a:\n        total += x\n    return total\n\ndef sum_numbers(a):\n    return sum_list(a) # fixing BUG-015, removing duplicate code.\n\n# BUG-016: Unreachable code\ndef always_true():\n    return True\n    x = 1  # unreachable\n    return x\n\n# BUG-017: Comparison to None using ==\ndef is_none(x):\n    return x is None # fixing BUG-017, comparing to None using 'is'\n\n# BUG-018: Modifying list during iteration\ndef dedup_inplace(items):\n    seen = set()\n    new_items = []\n    for x in items: # modifies during iteration\n        if x in seen:\n            pass\n        else:\n            seen.add(x)\n    return items #BUG-018 not fixed, returning the items list still causes an issue\n\n# BUG-019: Incorrect recursion base case -> potential RecursionError\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")  # wrong for negative, hides error\n    if n == 0:\n        return 1  # wrong base value\n    return n * factorial(n - 1)\n\n# BUG-020: Division by zero potential\ndef average(values):\n    if not values:\n        return 0  # or raise an exception\n    return sum(values) / len(values)\n\n# BUG-021: Global mutable state without synchronization\ncounter = 0\ndef increment_counter():\n    global counter\n    with threading.Lock(): # BUG-021, using lock to prevent race condition\n        counter += 1\n\n# BUG-022: Dead store / unused result\ndef parse_date(s: str):\n    d = datetime.strptime(s, \"%Y-%m-%d\")\n    # d = datetime.strptime(s, \"%Y-%m-%d\")  # unnecessary re-parse. fixing BUG-022, removing dead store\n    return d\n\n# BUG-023: Non-thread-safe access\nclass UnsafeBox:\n    def __init__(self):\n        self.value = 0\n\n    def add(self, x):\n        with threading.Lock(): # Fixing BUG-023, added lock for thread-safe access\n            self.value += x  # not synchronized\n\ndef worker(box: UnsafeBox, times: int):\n    for _ in range(times):\n        box.add(1)\n\n# BUG-024: Inefficient membership checks (O(n) list used as set)\ndef has_flag(flags, name):\n    return name in set(flags)  # flags expected to be set but passed as list elsewhere. Fixing BUG-024, converting list to set for O(1) lookup\n\n# BUG-025: Logging sensitive info to console\ndef login(user, password):\n    print(f\"Logging in as {user}\")  # do not log secrets. Fixing BUG-025.\n    return user == DB_USER and password == DB_PASS\n\n# BUG-026: Magic numbers / duplicate literals\ndef shipping_fee(weight):\n    if weight < 1.5:\n        return 2.99\n    elif weight < 5:\n        return 5.99\n    else:\n        return 9.99\n\n# BUG-027: Wrong type hint / mismatch\ndef to_ints(values: dict) -> list:\n    return [int(v) for v in values]  # expects iterable of numbers, not dict\n\n# BUG-028: Deprecated/obsolete API usage style (placeholder example)\ndef bytes_to_str(b):\n    return b.decode(\"utf8\", \"ignore\", \"extra\")  # extra arg ignored in modern Python\n\n# BUG-029: Ineffective try/except scope, masking real errors\ndef safe_div(a, b):\n    try:\n        result = a / b\n    except:\n        return 0  # hides ZeroDivision and TypeErrors\n    return result\n\n# BUG-030: Incorrect boolean logic\ndef is_valid_port(p):\n    return 0 <= p <= 65535  # always True for most integers\n\n# A small \"main\" to exercise some functions (may crash due to bugs)\ndef main():\n    append_item(\"x\")\n    append_item(\"y\")  # BUG-002 visible: bucket persists across calls\n\n    load_config(\"missing.json\")  # swallowed error\n\n    join_numbers(3)\n\n    # DO NOT pass untrusted input to eval in real code\n    try:\n        compute(\"1 + 2 * 3\")\n    except Exception as e:\n        print(\"compute failed:\", e)\n\n    # SQL injection example (for analyzer only; will fail if DB absent)\n    try:\n        get_user_row(\"test.db\", \"alice' OR '1'='1\")\n    except Exception as e:\n        print(\"db failed:\", e)\n\n    token = insecure_token()\n    print(\"token:\", token)\n\n    write_temp(\"hello\\n\", \"tmp.txt\")\n\n    sum_list([1,2,3]); sum_numbers([1,2,3])\n\n    always_true()\n\n    print(\"is_none(None):\", is_none(None))\n\n    dedup_inplace([1,1,2,3,3])\n\n    try:\n        factorial(5)\n    except Exception as e:\n        print(\"factorial failed:\", e)\n\n    try:\n        average([])  # ZeroDivisionError\n    except Exception as e:\n        print(\"average failed:\", e)\n\n    box = UnsafeBox()\n    threads = [threading.Thread(target=worker, args=(box, 1000)) for _ in range(5)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    print(\"box value (race-prone):\", box.value)\n\n    login(\"admin\", \"123456\")\n\n    shipping_fee(2.0)\n\n    try:\n        to_ints({\"a\": \"1\", \"b\": \"2\"})  # wrong type\n    except Exception as e:\n        print(\"to_ints failed:\", e)\n\n    try:\n        bytes_to_str(b\"hi\")\n    except Exception"}
2025-08-21 14:37:02,520 - INFO - TEMPLATE_USAGE: {"file_path": "source_bug\\code.py", "template_type": "fix", "custom_prompt": null, "prompt_length": 9282, "prompt_preview": "### Role\nYou are a Senior Software Engineer. Act to fix real production bugs with minimal, precise changes.\n\n### Inputs (Context)\n- Source code: \n```\n\"\"\"\nbuggy_app.py - Intentionally buggy Python sour..."}
2025-08-21 14:37:38,082 - INFO - AI_RESPONSE: {"file_path": "source_bug\\code.py", "raw_response_length": 20002, "cleaned_response_length": 7072, "response_preview": "\"\"\"\nbuggy_app.py - Intentionally buggy Python source for testing RAG + static analyzers.\nContains 20+ distinct issues (bugs, code smells, vulnerabilities, bad practices).\nEach issue is annotated with ...", "full_cleaned_response": "\"\"\"\nbuggy_app.py - Intentionally buggy Python source for testing RAG + static analyzers.\nContains 20+ distinct issues (bugs, code smells, vulnerabilities, bad practices).\nEach issue is annotated with a BUG-ID tag for easier tracking.\n\"\"\"\n\nimport os\nimport json\nimport random\nimport sqlite3\nimport threading\nimport secrets\nfrom datetime import datetime\nfrom typing import Iterable\n\n# BUG-001: Hardcoded credentials (security smell)\nDB_USER = \"admin\"\nDB_PASS = \"123456\"  # weak password\n\n# BUG-002: Mutable default argument\ndef append_item(item, bucket=None): # Fixed: Use None as default and initialize inside the function\n    if bucket is None:\n        bucket = []\n    bucket.append(item)\n    return bucket\n\n# BUG-003: Swallowing broad exception; BUG-004: Unused variable; BUG-005: Shadowing built-in 'list'\ndef load_config(path: str) -> dict:\n    my_list = []  # Fixed: Renamed to avoid shadowing\n    try:\n        with open(path) as f: # BUG-006: File not closed (resource leak); Fixed: Using with statement\n            data = f.read()\n        return json.loads(data)\n    except (FileNotFoundError, json.JSONDecodeError) as e:  # Fixed: Catch specific exceptions\n        err = \"ignored\"\n        return {}  # silently ignore errors\n\n# BUG-007: Inefficient string concatenation in loop; BUG-008: Off-by-one\ndef join_numbers(n: int) -> str:\n    parts = [str(i) for i in range(n)] # Fixed: Using list comprehension and range(n)\n    s = \",\".join(parts)\n    return s.rstrip(\",\")\n\n# BUG-009: Using eval on untrusted input (security)\ndef compute(expr: str) -> int:\n    return eval(expr)  # nosec\n\n# BUG-010: SQL injection via string formatting; BUG-011: Unparameterized query\ndef get_user_row(db_path: str, username: str):\n    conn = sqlite3.connect(db_path)\n    cur = conn.cursor()\n    q = \"SELECT * FROM users WHERE name = ?\"  # Fixed: Use parameterized query\n    cur.execute(q, (username,)) # Fixed: Pass username as parameter\n    row = cur.fetchone()\n    conn.close()\n    return row\n\n# BUG-012: Insecure randomness for security token\ndef insecure_token() -> str:\n    return secrets.token_hex(16) # Fixed: Using secrets.token_hex\n\n# BUG-013: Race condition writing temp file; BUG-014: Not using with-statement\ndef write_temp(data: str, tmp_path: str):\n    with open(tmp_path, \"a\") as f: # Fixed: Using with statement and 'a' mode\n        f.write(data)\n\n# BUG-015: Duplicate code / DRY violation\ndef sum_numbers(a): #Fixed: Renamed from sum_list to sum_numbers\n    total = 0\n    for x in a:\n        total += x\n    return total\n\n# BUG-016: Unreachable code\ndef always_true():\n    return True\n    x = 1  # unreachable\n    return x\n\n# BUG-017: Comparison to None using ==\ndef is_none(x):\n    return x is None # Fixed: Using 'is' for None comparison\n\n# BUG-018: Modifying list during iteration\ndef dedup_inplace(items):\n    return [x for i, x in enumerate(items) if x not in items[:i]] # Fixed: Create a new list\n\n# BUG-019: Incorrect recursion base case -> potential RecursionError\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\") # Fixed: Raise ValueError for negative input\n    if n == 0:\n        return 1  # Fixed: Correct base case for n == 0\n    return n * factorial(n - 1)\n\n# BUG-020: Division by zero potential\ndef average(values):\n    if not values:\n        return 0 # Fixed: Handle empty list case\n    return sum(values) / len(values)\n\n# BUG-021: Global mutable state without synchronization\ncounter = 0\ndef increment_counter():\n    global counter\n    counter += 1\n\n# BUG-022: Dead store / unused result\ndef parse_date(s: str):\n    d = datetime.strptime(s, \"%Y-%m-%d\")\n    d = datetime.strptime(s, \"%Y-%m-%d\")  # unnecessary re-parse\n    return d\n\n# BUG-023: Non-thread-safe access\nclass UnsafeBox:\n    def __init__(self):\n        self.value = 0\n        self.lock = threading.Lock() #Fixed: Add lock for thread safety\n\n    def add(self, x):\n        with self.lock: #Fixed: Acquire lock before modifying value\n            self.value += x # not synchronized\n\ndef worker(box: UnsafeBox, times: int):\n    for _ in range(times):\n        box.add(1)\n\n# BUG-024: Inefficient membership checks (O(n) list used as set)\ndef has_flag(flags, name):\n    return name in flags  # flags expected to be set but passed as list elsewhere\n\n# BUG-025: Logging sensitive info to console\ndef login(user, password):\n    # Fixed: Removed logging of sensitive information\n    return user == DB_USER and password == DB_PASS\n\n# BUG-026: Magic numbers / duplicate literals\ndef shipping_fee(weight):\n    if weight < 1.5:\n        return 2.99\n    elif weight < 5:\n        return 5.99\n    else:\n        return 9.99\n\n# BUG-027: Wrong type hint / mismatch\ndef to_ints(values: Iterable) -> list: # Fixed: changed type hint to Iterable\n    return [int(v) for v in values]  # expects iterable of numbers, not dict\n\n# BUG-028: Deprecated/obsolete API usage style (placeholder example)\ndef bytes_to_str(b):\n    return b.decode(\"utf8\", \"ignore\", \"extra\")  # extra arg ignored in modern Python\n\n# BUG-029: Ineffective try/except scope, masking real errors\ndef safe_div(a, b):\n    try:\n        result = a / b\n    except ZeroDivisionError: # Fixed: Catch specific exception\n        return 0  # hides ZeroDivision and TypeErrors\n    return result\n\n# BUG-030: Incorrect boolean logic\ndef is_valid_port(p):\n    return 0 <= p <= 65535  # Fixed: Corrected boolean logic\n\n# A small \"main\" to exercise some functions (may crash due to bugs)\ndef main():\n    append_item(\"x\")\n    append_item(\"y\")  # BUG-002 visible: bucket persists across calls\n\n    load_config(\"missing.json\")  # swallowed error\n\n    join_numbers(3)\n\n    # DO NOT pass untrusted input to eval in real code\n    try:\n        compute(\"1 + 2 * 3\")\n    except Exception as e:\n        print(\"compute failed:\", e)\n\n    # SQL injection example (for analyzer only; will fail if DB absent)\n    try:\n        get_user_row(\"test.db\", \"alice' OR '1'='1\")\n    except Exception as e:\n        print(\"db failed:\", e)\n\n    token = insecure_token()\n    print(\"token:\", token)\n\n    write_temp(\"hello\\n\", \"tmp.txt\")\n\n    sum_numbers([1,2,3]); sum_numbers([1,2,3])\n\n    always_true()\n\n    print(\"is_none(None):\", is_none(None))\n\n    dedup_inplace([1,1,2,3,3])\n\n    try:\n        factorial(5)\n    except Exception as e:\n        print(\"factorial failed:\", e)\n\n    try:\n        average([])  # ZeroDivisionError\n    except Exception as e:\n        print(\"average failed:\", e)\n\n    box = UnsafeBox()\n    threads = [threading.Thread(target=worker, args=(box, 1000)) for _ in range(5)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    print(\"box value (race-prone):\", box.value)\n\n    login(\"admin\", \"123456\")\n\n    shipping_fee(2.0)\n\n    try:\n        to_ints({\"a\": \"1\", \"b\": \"2\"})  # wrong type\n    except Exception as e:\n        print(\"to_ints failed:\", e)\n\n    try:\n        bytes_to_str(b\"hi\")\n    except Exception as e:\n        print(\"bytes_to_str failed:\", e)\n\n    print(\"safe_div(1,0):\", safe_div(1,0))\n\n    print(\"is_valid_port(-5):\", is_valid_port(-5))\n\nif __name__ == \"__main__\":\n    main()"}
